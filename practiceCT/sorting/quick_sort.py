# 퀵 정렬
'''
핵심 동작원리

-기준 데이터를 설정하고 그 기준보다 큰 데이터와 작은 데이터의 위치를 바꾸는 방법.
-일반적인 상황에서 가장 많이 사용되는 정렬 알고리즘 중 하나.
-병합 정렬과 더불어 대부분의 프로그래밍 언어의 정렬 라이브러리의 근간이 되는 알고리즘.
-가장 기본적인 퀵 정렬은 첫 번째 데이터를 기준 데이터(Pivot)로 설정.
'''

'''
예시

Step 0
5 7! 9 0 3 1 6 2 4! 8
현재 피벗(기준)의 값은 '5' 이다.
왼쪽에서부터 '5' 보다 큰 데이터를 선택하므로 '7' 이 선택되고,
오른쪽에서부터 '5'보다 작은 데이터를 선택하므로 '4'가 선택된다.
이제 두 데이터의 위치를 서로 변경한다.

Step 1
그럼 다음과 같이 5 4! 9 0 3 1 6 2 7! 8   '4'와 '7'의 위치가 서로 바뀐다.
그 후 현재 피벗의 값은 '5',
5 4 9! 0 3 1 6 2! 7 8
왼쪽에서 부터 '5'보다 큰 데이터를 선택하므로 '9'가 선택되고,
오른쪽에서부터 '5'보다 작은 데이터를 선택하므로 '2'가 선택된다.
이제 두 데이터의 위치를 서로 변경한다.

Step2
5 4 2! 0 3 1 6 9! 7 8 그럼 이렇게 또 변경된다.

5 4 2 0 3 1! 6! 9 7 8
다시 또 왼쪽에서부터 '5'보다 큰 데이터를 선택하므로 '6'이 선택되고,
오른쪽에서부터 '5'보다 작은 데이터를 선택하므로 '1'이 선택된다.
단 위처럼 위치가 엇갈리는 경우 '피벗'과 '작은 데이터'의 위치를 서로 변경한다.

분할 완료
즉, 1! 4 2 0 3 5! 6! 9 7 8
다음과 같이 정렬된다.
이제 '5' 왼쪽에 있는 데이터는 모두 5보다 작고,
오른쪽에 있는 데이터는 모두'5'보다 크다는 특징이 있다.
이렇게 피벗을 기준으로 데이터 묶음을 나누는 작업을 분할(Divide)이라고 한다.
즉, 이렇게 하나의 피벗값에 대해서 정렬을 위한 데이터의 범위가
왼쪽과 오른쪽으로 나누어진다는 점에서 이러한 작업을 분할이라 한다.
혹은 partition 이라고도 한다.

이제 이어서 왼쪽에 있는 데이터들, 그리고 오른쪽에 있는 데이터들을
각각을 하나의 배열로 판단을 해서
[왼쪽 데이터 묶음 정렬] 왼쪽에 잇는 데이터에 대해서 마찬가지로 정렬수행.(피벗 1설정 후)
오른쪽도 마찬가지로 다시 퀵 정렬을 수행.

이처럼 퀵 정렬이 수행되는 과정은 재귀적으로 수행이 되고
수행될 때마다 정렬을 위한 범위가 점점 좁아지는 형태로 진행된다.
'''
'''
이상적인 경우 분할이 절반씩 일어난다면 전체 연산 횟수로 O(NlogN)를 기대할 수 있다.
  너비 X 높이 = N * logN = NlogN ( 밑이 2 인 로그 )

퀵 정렬은 평균의 경우 O(NlogN)의 시작 복잡도를 가지고,
최악의 경우 O(N^2)의 시간 복잡도를 가진다.
  첫 번째 원소를 피벗으로 삼을 때, 이미 정렬된 배열에 대해서 퀵 정렬을 수행하면?
  0 1 2 3 4 5 6 7 8 9 면 피벗이 0이라 오른쪽에서부터 다 0보다 크기때문에
  작은값을 찾기위해 끝까지 왼쪽으로 옴..
  그래서 자기자신의 위치로 변경되기에 분할이 되었을때
  왼쪽이 없이 오른쪽 부분만 존재하고 매번 분할이 이루어 질때마다
  오른쪽 데이터만 남는형태로 이루어짐.
  다시말해 최악의 경우 분할의 수행 횟수가 N과 비례하고 
  분할을 하기위해 매번 선형탐색을 해야하기에 시간복잡도가 N^2인 것.

하지만 표준 라이브러리를 이용하면 기본적으로 NlogN을 항상 보장한다.
내가 피벗 첫번째 원소두고 할때만 N^2 걱정하자.
'''

array = [5, 7, 9, 0, 3, 1, 6, 2, 4, 8]


def quick_sort(array, start, end):
    if start >= end:  # 원소가 1개인 경우 종료
        return
    pivot = start  # 피벗은 첫 번째 원소
    left = start + 1
    right = end
    while(left <= right):
        # 피벗보다 큰 데이터를 찾을 때까지 반복
        while(left <= end and array[left] <= array[pivot]):
            left += 1
        # 피벗보다 작은 데이터를 찾을 때까지 반복
        while(right > start and array[right] >= array[pivot]):
            right -= 1
        if(left > right):  # 엇갈렸다면 작은 데이터와 피벗을 교체
            array[right], array[pivot] = array[pivot], array[right]
        else:  # 엇갈리지 않았다면 작은 데이터와 큰 데이터를 교체
            array[left], array[right] = array[right], array[left]
    # 분할 이후 왼쪽 부분과 오른쪽 부분에서 각각 정렬 수행
    quick_sort(array, start, right - 1)
    quick_sort(array, right + 1, end)


quick_sort(array, 0, len(array) - 1)
print(array)


# 좀 더 간결히
array2 = [5, 7, 9, 0, 3, 1, 6, 2, 4, 8]


def quick_sort2(array2):
    # 리스트가 하나 이하의 원소만을 담고 있다면 종료
    if len(array2) <= 1:
        return array2
    pivot2 = array2[0]  # 피벗은 첫 번째 원소
    tail = array2[1:]  # 피벗을 제외한 리스트

    left_side = [x for x in tail if x <= pivot2]  # 분할된 왼쪽 부분
    right_side = [x for x in tail if x > pivot2]  # 분할된 오른쪽 부분

    # 분할 이후 왼쪽 부분과 오른쪽 부분에서 각각 정렬 수행하고, 전체 리스트 반환
    return quick_sort2(left_side) + [pivot2] + quick_sort2(right_side)


print(quick_sort2(array2))
