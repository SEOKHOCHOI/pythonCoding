# 순차 탐색: 리스트 안에 있는 특정한 데이터를 찾기 위해 앞에서부터 데이터를 하나씩 확인하는 방법
# + 이러한 순차탐색은 가장 기본적인 형태의 데이터 탐색 알고리즘이다.
# + 선택 정렬에서 매 단계마다 가장 작은 크기의 데이터를 찾는 과정도 순차탐색을 이용했다고 볼수있음.
# + 리스트에서 특정 데이터가 존재하는지를 검사할때 별다른 말이 없다면 기본적으로 순차탐색을 이용한다고 볼 수 있다.

# 이진 탐색(binary search): 정렬되어 있는 리스트에서 탐색 범위를 절반씩 좁혀가며 데이터를 탐색하는 방법
# + 이진 탐색은 시작점, 끝점, 중간점을 이용하여 탁색 범위를 설정한다.

'''
예시)
이미 정렬된 10개의 데이터 중에서 값이 4인 원소를 찾아보자!
0 2 4 6 8 10 12 14 16 18 중에서 4를 찾아보자.
시작점:0, 끝점:9, 중간점:4 (소수점 이하 제거)
이때 시작점과 끝점은 각각 인덱스를 이야기 하는 것! 그럼 자연스럽게 중간지점은 인덱스 4에 해당! 즉,
0(시작점[0]) 2 4 6 8(중간점[4]) 10 12 14 16 18(끝점[9]) 이다.

일반적으로 위처럼 중간점이 2개 존재할수 있는 경우에는 실제 중간점 인덱스 값에서
소수점 이하는 제거해서 단순히 4라고 표현하는 방법 사용가능! (0과 9의 중간이 8과10의 사이인 4.5니까 4로 해준것.)
그래서 이와같이 중간점에 위치하는 값인 8과 찾고자 하는 값인 4와 비교하여
어떤값이 더 큰지 비교하여 만약 찾고자 하는 값보다 현재 중간점 위치의 값이 더 크다면
중간점에서부터 오른쪽의 있는 값들은 전부 다 확인할 필요가 없게된다.

왜냐하면 오른쪽의 값들은 전부 8 이상의 값이기에 찾고자 하는 4보다 더 크다.
그래서 중간점을 포함하여 오른쪽은 볼 필요가 없어진것.

그 다음 순서는 이제 끝점을 중간점의 바로 왼쪽으로 옮겨 탐색 범위를 
0 2 4 6(이제끝점) 이 돼 탐색 범위가 4개로 좁혀지게 된다.
이때 2가 중간점이 된다.

이 경우엔 중간점 값인2보다 찾고자 하는 값인 4가 더 크기 때문에 
마찬가지로 중간점을 포함해 왼쪽 데이터는 볼 필요가 없다.

그래서 이번엔 시적점 위치를 중간점 오른쪽으로 옮겨준다.

이때는 시작점이 인덱스 2인 4이고 끝점은 인덱스3인 6이다.
이때 중간점 위치또한 4인데 우리가 찾고자 하는 값인 4와 동일하기에
여기에서 탐색을 마친다.

즉, 우리가 찾고자 하는 값인 4는 인덱스 2에 위치해 있다는걸 확인할수 있고
이를 통해서 우리는 총 세번의 스텝만으로 우리가 찾고자 하는 값이 존재하는지
존재한다면 어느 위치에 존재하는지 확인할수있다.
'''
'''
이진 탐색의 시간 복잡도
단계마다 탐색 범위를 2로 나누는 것과 동일하므로 연산 횟수는 logN에 비례한다.(밑은 2이다.)
예를 들어 초기 데이터 개수가 32개일 때, 이상적으로 1단계를 거치면 16개 가량의 데이터만 남는다.
  2단계를 거치면 8개가량의 데이터만 남는다.
  3단계를 거치면 4개가량의 데이터만 남는다.
다시 말해 이진 탐색은 탐색 범위를 절반씩 줄이며, 시간 복잡도는 O(logN)을 보장한다.
'''
# 이진 탐색 소스코드: 재귀적 구현 (재귀 함수이용해 작성함)
# 탐색을 수행하고자 하는 배열정보(array)가 들어오고
# 찾고자 하는 데이터(target), 이어서 탐색범위(start, end) 주어지게 된다.


def binary_search(array, target, start, end):
    if start > end:
        return None
    mid = (start + end) // 2
    # 찾은 경우 중간점 인덱스 반환
    if array[mid] == target:
        return mid
    # 중간점의 값보다 찾고자 하는 값이 작은 경우 왼쪽 확인
    elif array[mid] > target:
        return binary_search(array, target, start, mid - 1)
    # 중간점의 값보다 찾고자 하는 값이 큰 경우 오른쪽 확인
    else:
        return binary_search(array, target, mid + 1, end)


# n(원소의 개수)과 target(찾고자 하는 값)을 입력 받기
n, target = list(map(int, input().split()))
# 전체 원소 입력 받기
array = list(map(int, input().split()))

# 이진 탐색 수행 결과 출력
result = binary_search(array, target, 0, n - 1)
if result == None:
    print("원소가 존재하지 않습니다.")
else:
    print(result + 1)


# 이진 탐색 소스코드 구현 (반복문)
def binary_search2(array, target, start, end):
    while start <= end:
        mid = (start + end) // 2
        if array[mid] == target:
            return mid
        elif array[mid] > target:
            end = mid - 1
        else:
            start = mid + 1
    return None


n, taret = list(map(int, input().split()))
array = list(map(int, input().split()))
result = binary_search(array, target, 0, n - 1)
if result == None:
    print("원소가 존재하지 않습니다.(반복분)")
else:
    print("(반복문)", result + 1)
